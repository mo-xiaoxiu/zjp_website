# AOSP组件源码：Looper

套用源码注释的一段话描述清楚`Looper`：

> 一个支持监控文件描述符事件的轮询循环，可选择使用回调。该实现内部使用`epoll()`。*Looper可以与线程关联，虽然没有要求必须这样做。*

## Looper组件

AOSP 的 `Looper`是一个极其核心的**事件循环 (Event Loop)** 机制，位于 `frameworks/native/libs/utils/`和 `system/core/libutils/`。

### 职责与设计

AOSP 的 `Looper`是一个**高效的 I/O 多路复用器与消息调度器**。它的核心设计哲学是：**让一个线程能够无限循环，阻塞等待多个输入源（文件描述符）上的事件，一旦事件发生，便分发并处理它们，从而实现单线程内的异步、非阻塞操作。**

### 工作原理与三要素

其工作模型围绕三个关键要素构建：

1. **监听源 (File Descriptors)**:
   * Looper 的核心是监听 **文件描述符 (fd)** 上的事件。在 Linux 中，一切皆文件，socket、管道 (pipe)、标准输入输出、Binder 驱动提供的 fd 等都可以被 Looper 监听。
   * 常见事件类型包括：
     * `EVENT_INPUT`: 文件描述符上有数据可读。
     * `EVENT_OUTPUT`: 文件描述符可写入。
     * `EVENT_ERROR`: 文件描述符发生错误。
2. **事件循环 (Loop)**:
   * 线程通过调用 `Looper::pollOnce()`或 `Looper::pollAll()`进入一个无限循环。
   * 在这个循环内，它会使用 **`epoll`**来同时监视所有注册了的文件描述符。
   * 此调用是**阻塞的**。线程会在此休眠，直到以下情况发生：
     * 某个被监听的 fd 发生了感兴趣的事件。
     * 设定的超时时间已到。
     * 被其他线程通过 `Looper::wake()`唤醒。
3. **回调处理 (Callback)**:
   * 当 `pollOnce`因 fd 事件而返回时，Looper 会查找与该 fd 关联的**回调函数** (`Looper_callbackFunc`)。
   * 然后，它会在**当前线程**（即运行 Looper 的线程）同步执行这个回调函数，从而处理事件。
   * 回调函数的返回值决定 Looper 后续是否继续监听此 fd：返回 `1`继续监听，返回 `0`则移除监听。

### 特性与能力

* **线程单例性**: 每个线程最多只能拥有一个 Looper 对象，通过 `Looper::getForThread()`和 `Looper::setForThread()`管理，确保了线程内事件处理的秩序。
* **精准唤醒**: 任何线程都可以通过调用另一个线程的 Looper 的 `wake()`方法，精确地唤醒目标线程的 `pollOnce`调用。这是实现跨线程任务同步和优雅退出的关键。
* **超时控制**: `pollOnce`支持传入超时参数，允许循环在无事件时定期唤醒执行一些逻辑（如处理超时任务）。

## 源码分析



